name: Build Hadoop on Windows (Artifacts Repository)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      hadoop_repo:
        description: 'Hadoop repository URL'
        required: false
        default: 'https://github.com/apache/hadoop.git'
      hadoop_branch:
        description: 'Hadoop branch/tag to build'
        required: false
        default: 'trunk'
      build_type:
        description: 'Build type'
        required: false
        default: 'release'
        type: choice
        options:
          - release
          - snapshot
      skip_tests:
        description: 'Skip tests during build'
        required: false
        default: true
        type: boolean

  # Configuration for artifacts repository
  HADOOP_REPO: ${{ github.event.inputs.hadoop_repo || 'https://github.com/apache/hadoop.git' }}
  HADOOP_BRANCH: ${{ github.event.inputs.hadoop_branch || 'trunk' }}
  BUILD_TYPE: ${{ github.event.inputs.build_type || 'release' }}
  SKIP_TESTS: ${{ github.event.inputs.skip_tests || 'true' }}
  
  # Version requirements from BUILDING.txt
  JAVA_VERSION: '8'
  MAVEN_VERSION: '3.3.9'
  BOOST_VERSION: '1.86.0'
  PROTOBUF_VERSION: '3.21.12'
  CMAKE_VERSION: '3.19.8'
  VCPKG_COMMIT: '2025.03.19'
  ZLIB_VERSION: '1.2.7'

jobs:
  build-hadoop-windows:
    runs-on: windows-latest  # Uses Windows Server 2022
    
    steps:
    - name: Checkout Artifacts Repository
      uses: actions/checkout@v4
      with:
        path: artifacts-repo

    - name: Enable Long Paths on Windows
      run: |
        Write-Host "=== Enabling Long Path Support ==="
        
        # Enable long path support for Git globally
        git config --global core.longpaths true
        Write-Host "Git long paths enabled globally"
        
        # Check current Git configuration
        Write-Host "Current Git long paths setting: $(git config --global core.longpaths)"
        
        # Enable long path support at system level (requires admin)
        try {
          $currentValue = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled" -ErrorAction SilentlyContinue
          if ($currentValue) {
            Write-Host "Current LongPathsEnabled value: $($currentValue.LongPathsEnabled)"
          } else {
            Write-Host "LongPathsEnabled registry key not found"
          }
          
          New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled" -Value 1 -PropertyType DWORD -Force
          Write-Host "Long paths enabled successfully in registry"
        } catch {
          Write-Host "Registry modification failed (may not have permissions): $($_.Exception.Message)"
        }
        
        # Test path length limits
        Write-Host "=== Testing Path Length Support ==="
        $testPath = "C:\very_long_test_directory_name_to_check_if_long_paths_are_working_properly_on_this_system_with_maximum_character_limits"
        try {
          New-Item -ItemType Directory -Path $testPath -Force
          Write-Host "âœ… Long path test successful - created directory with $(($testPath).Length) characters"
          Remove-Item -Path $testPath -Force
        } catch {
          Write-Host "âŒ Long path test failed: $($_.Exception.Message)"
        }

    - name: Prepare Short Path Directory
      run: |
        Write-Host "=== Preparing Short Path Directory ==="
        
        $shortPath = "C:\h"
        if (Test-Path $shortPath) {
          Write-Host "Removing existing directory: $shortPath"
          Remove-Item -Recurse -Force $shortPath
        }
        
        # Pre-create the directory
        New-Item -ItemType Directory -Path $shortPath -Force
        Write-Host "Created short path directory: $shortPath"
        
        # Set directory permissions to full control
        try {
          $acl = Get-Acl $shortPath
          $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("Everyone","FullControl","Allow")
          $acl.SetAccessRule($accessRule)
          Set-Acl -Path $shortPath -AclObject $acl
          Write-Host "Set full permissions on directory"
        } catch {
          Write-Host "Could not set permissions: $($_.Exception.Message)"
        }

    - name: Clone Hadoop Repository
      run: |
        Write-Host "=== Cloning Hadoop Repository ==="
        
        $shortPath = "C:\h"
        $repo = "${{ env.HADOOP_REPO }}"
        $branch = "${{ env.HADOOP_BRANCH }}"
        
        Write-Host "Repository: $repo"
        Write-Host "Branch/Tag: $branch"
        Write-Host "Target Path: $shortPath"
        Write-Host "Current Directory: $(Get-Location)"
        
        # Set Git configuration for this operation
        git config --global core.autocrlf false
        git config --global core.longpaths true
        git config --global core.preloadindex true
        git config --global core.fscache true
        
        Write-Host "Git configurations set"
        
        # Change to C:\ to minimize path length during clone
        Set-Location C:\
        
        try {
          Write-Host "Starting git clone..."
          
          # Use sparse-checkout to potentially reduce issues
          git clone --filter=blob:none --config core.longpaths=true --depth 1 --branch $branch $repo h
          
          Write-Host "Clone completed, checking status..."
          
          Set-Location h
          
          # Force checkout to resolve any issues
          Write-Host "Forcing checkout of all files..."
          git config core.longpaths true
          git checkout HEAD -- .
          
          Write-Host "Repository cloned successfully!"
          
          $commit = git rev-parse HEAD
          Write-Host "Commit: $commit"
          echo "HADOOP_COMMIT=$commit" >> $env:GITHUB_ENV
          
          # Get version using Maven
          Write-Host "Getting Hadoop version..."
          $version = mvn help:evaluate -Dexpression=project.version -q -DforceStdout
          Write-Host "Version: $version"
          echo "HADOOP_VERSION=$version" >> $env:GITHUB_ENV
          echo "HADOOP_SOURCE_DIR=C:\h" >> $env:GITHUB_ENV
          
        } catch {
          Write-Host "âŒ Clone failed with error: $($_.Exception.Message)"
          
          # Try alternative approach - shallow clone without branch specification
          Write-Host "Trying alternative clone method..."
          try {
            if (Test-Path "h") { Remove-Item -Recurse -Force "h" }
            
            git init h
            Set-Location h
            git config core.longpaths true
            git remote add origin $repo
            git fetch --depth 1 origin $branch
            git checkout FETCH_HEAD
            
            $commit = git rev-parse HEAD
            Write-Host "Alternative clone successful! Commit: $commit"
            echo "HADOOP_COMMIT=$commit" >> $env:GITHUB_ENV
            
            $version = mvn help:evaluate -Dexpression=project.version -q -DforceStdout
            echo "HADOOP_VERSION=$version" >> $env:GITHUB_ENV
            echo "HADOOP_SOURCE_DIR=C:\h" >> $env:GITHUB_ENV
            
          } catch {
            Write-Host "âŒ Alternative clone also failed: $($_.Exception.Message)"
            
            # List what we have
            Write-Host "Current directory contents:"
            Get-ChildItem -Force | Format-Table
            
            if (Test-Path "C:\h") {
              Write-Host "Contents of C:\h:"
              Get-ChildItem "C:\h" -Force | Format-Table
            }
            
            throw "All clone attempts failed"
          }
        }

    - name: Verify Repository State
      run: |
        Write-Host "=== Verifying Repository State ==="
        
        Set-Location C:\h
        
        Write-Host "Current directory: $(Get-Location)"
        Write-Host "Directory contents:"
        Get-ChildItem | Format-Table Name, Length, LastWriteTime
        
        Write-Host "Git status:"
        git status --porcelain
        
        Write-Host "Checking for problematic long paths:"
        $longPaths = @()
        Get-ChildItem -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
          if ($_.FullName.Length -gt 240) {
            $longPaths += $_.FullName
          }
        }
        
        if ($longPaths.Count -gt 0) {
          Write-Host "Found $($longPaths.Count) paths longer than 240 characters:"
          $longPaths | ForEach-Object { Write-Host "  Length $($_.Length): $_" }
        } else {
          Write-Host "âœ… No problematic long paths found"
        }
        
        # Verify key files exist
        $keyFiles = @("pom.xml", "hadoop-dist/pom.xml", "dev-support/bin/create-release")
        foreach ($file in $keyFiles) {
          if (Test-Path $file) {
            Write-Host "âœ… Found: $file"
          } else {
            Write-Host "âŒ Missing: $file"
          }
        }
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Verify Repository State
      run: |
        Write-Host "=== Verifying Repository State ==="
        
        Set-Location C:\h
        
        Write-Host "Current directory: $(Get-Location)"
        Write-Host "Directory contents:"
        Get-ChildItem | Format-Table Name, Length, LastWriteTime
        
        Write-Host "Git status:"
        git status --porcelain
        
        Write-Host "Checking for problematic long paths:"
        $longPaths = @()
        Get-ChildItem -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
          if ($_.FullName.Length -gt 240) {
            $longPaths += $_.FullName
          }
        }
        
        if ($longPaths.Count -gt 0) {
          Write-Host "Found $($longPaths.Count) paths longer than 240 characters:"
          $longPaths | ForEach-Object { Write-Host "  Length $($_.Length): $_" }
        } else {
          Write-Host "âœ… No problematic long paths found"
        }
        
        # Verify key files exist
        $keyFiles = @("pom.xml", "hadoop-dist/pom.xml", "dev-support/bin/create-release")
        foreach ($file in $keyFiles) {
          if (Test-Path $file) {
            Write-Host "âœ… Found: $file"
          } else {
            Write-Host "âŒ Missing: $file"
          }
        }

    - name: Set up Maven
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        maven-version: ${{ env.MAVEN_VERSION }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Setup Git (with Unix tools)
      run: |
        # Ensure Git with Unix tools is available
        echo "C:\Program Files\Git\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        echo "C:\Program Files\Git\usr\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v1.3

    - name: Setup MSVC Dev Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
        toolset: 14.29

    - name: Cache vcpkg
      uses: actions/cache@v3
      id: cache-vcpkg
      with:
        path: |
          C:\vcpkg
          C:\Users\runneradmin\.vcpkg
        key: ${{ runner.os }}-vcpkg-${{ env.VCPKG_COMMIT }}-${{ env.BOOST_VERSION }}-${{ env.PROTOBUF_VERSION }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-${{ env.VCPKG_COMMIT }}-

    - name: Install vcpkg and dependencies
      if: steps.cache-vcpkg.outputs.cache-hit != 'true'
      shell: cmd
      run: |
        cd C:\
        git clone https://github.com/microsoft/vcpkg.git
        cd vcpkg
        git fetch --all
        git checkout %VCPKG_COMMIT%
        call bootstrap-vcpkg.bat
        echo {^
          "name": "hadoop-dependencies",^
          "version": "1.0.0",^
          "dependencies": [^
            "boost-system",^
            "boost-filesystem",^
            "boost-thread",^
            "boost-iostreams",^
            "protobuf",^
            "openssl",^
            "zlib"^
          ]^
        } > vcpkg.json
        vcpkg.exe install --x-install-root .\installed

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2/repository
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
        restore-keys: |
          ${{ runner.os }}-maven-

    - name: Set Environment Variables
      shell: cmd
      run: |
        echo PROTOBUF_HOME=C:\vcpkg\installed\x64-windows>> %GITHUB_ENV%
        echo ZLIB_HOME=C:\vcpkg\installed\x64-windows>> %GITHUB_ENV%
        echo OPENSSL_ROOT_DIR=C:\vcpkg\installed\x64-windows>> %GITHUB_ENV%
        echo MAVEN_OPTS=-Xmx2048M -Xss128M>> %GITHUB_ENV%
        echo IS_WINDOWS=1>> %GITHUB_ENV%

    - name: Verify Dependencies
      shell: cmd
      run: |
        echo "=== Java Version ==="
        java -version
        echo "=== Maven Version ==="
        mvn --version
        echo "=== CMake Version ==="
        cmake --version
        echo "=== Git Version ==="
        git --version
        echo "=== Python Version ==="
        python --version
        echo "=== Environment Variables ==="
        echo PROTOBUF_HOME=%PROTOBUF_HOME%
        echo ZLIB_HOME=%ZLIB_HOME%
        echo OPENSSL_ROOT_DIR=%OPENSSL_ROOT_DIR%
        echo MAVEN_OPTS=%MAVEN_OPTS%

    - name: Build Hadoop (Clean Package)
      shell: cmd
      working-directory: C:\h
      run: |
        set classpath=
        if "%SKIP_TESTS%"=="true" (
          set TEST_ARGS=-DskipTests
        ) else (
          set TEST_ARGS=
        )
        
        mvn clean package ^
          -Dhttps.protocols=TLSv1.2 ^
          %TEST_ARGS% ^
          -DskipDocs ^
          -Pnative-win,dist ^
          -Dskip.platformToolsetDetection ^
          -Drequire.openssl ^
          -Drequire.test.libhadoop ^
          -Pyarn-ui ^
          -Dshell-executable=C:\Program Files\Git\bin\bash.exe ^
          -Dtar ^
          -Dopenssl.prefix=C:\vcpkg\installed\x64-windows ^
          -Dcmake.prefix.path=C:\vcpkg\installed\x64-windows ^
          -Dwindows.cmake.toolchain.file=C:\vcpkg\scripts\buildsystems\vcpkg.cmake ^
          -Dwindows.cmake.build.type=RelWithDebInfo ^
          -Dwindows.build.hdfspp.dll=off ^
          -Dwindows.no.sasl=on ^
          -Duse.platformToolsetVersion=v142

    - name: Run Tests (Optional)
      shell: cmd
      working-directory: C:\h
      if: env.SKIP_TESTS == 'false'
      run: |
        mvn test ^
          -Pnative-win ^
          -Dskip.platformToolsetDetection ^
          -Drequire.openssl ^
          -Dopenssl.prefix=C:\vcpkg\installed\x64-windows ^
          -Dcmake.prefix.path=C:\vcpkg\installed\x64-windows ^
          -Dwindows.cmake.toolchain.file=C:\vcpkg\scripts\buildsystems\vcpkg.cmake ^
          -Dwindows.cmake.build.type=RelWithDebInfo ^
          -Dwindows.build.hdfspp.dll=off ^
          -Dwindows.no.sasl=on ^
          -Duse.platformToolsetVersion=v142

    - name: Create Release Tarball
      shell: bash
      working-directory: /c/h
      run: |
        export IS_WINDOWS=1
        export MVN_ARGS="-Dshell-executable=/c/Program\ Files/Git/bin/bash.exe -Dhttps.protocols=TLSv1.2 -Pnative-win -Dskip.platformToolsetDetection -Drequire.openssl -Dopenssl.prefix=C:/vcpkg/installed/x64-windows -Dcmake.prefix.path=C:/vcpkg/installed/x64-windows -Dwindows.cmake.toolchain.file=C:/vcpkg/scripts/buildsystems/vcpkg.cmake -Dwindows.cmake.build.type=RelWithDebInfo -Dwindows.build.hdfspp.dll=off -Duse.platformToolsetVersion=v142 -Dwindows.no.sasl=on -DskipTests -DskipDocs -Drequire.test.libhadoop"
        ./dev-support/bin/create-release --mvnargs="$MVN_ARGS"

    - name: Copy Artifacts to Artifacts Repository
      shell: bash
      run: |
        # Create artifacts directory structure
        mkdir -p artifacts-repo/builds/windows/
        TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
        BUILD_DIR="artifacts-repo/builds/windows/hadoop-${HADOOP_VERSION}-${TIMESTAMP}-${HADOOP_COMMIT:0:8}"
        mkdir -p "$BUILD_DIR"
        
        # Copy build artifacts from short path
        if ls /c/h/hadoop-dist/target/*.tar.gz 1> /dev/null 2>&1; then
          cp /c/h/hadoop-dist/target/*.tar.gz "$BUILD_DIR/"
        fi
        if ls /c/h/hadoop-dist/target/*.zip 1> /dev/null 2>&1; then
          cp /c/h/hadoop-dist/target/*.zip "$BUILD_DIR/"
        fi
        
        # Create build metadata
        cat > "$BUILD_DIR/build-info.json" << EOF
        {
          "build_timestamp": "$TIMESTAMP",
          "hadoop_version": "$HADOOP_VERSION",
          "hadoop_commit": "$HADOOP_COMMIT",
          "hadoop_branch": "$HADOOP_BRANCH",
          "hadoop_repository": "$HADOOP_REPO",
          "build_type": "$BUILD_TYPE",
          "runner_os": "windows-latest",
          "workflow_run_id": "${{ github.run_id }}",
          "workflow_run_number": "${{ github.run_number }}",
          "path_workaround": "Used C:\\h short path to avoid Windows path limitations"
        }
        EOF
        
        # Create/update index
        echo "# Hadoop Windows Builds" > artifacts-repo/builds/windows/README.md
        echo "" >> artifacts-repo/builds/windows/README.md
        echo "## Build Notes" >> artifacts-repo/builds/windows/README.md
        echo "- All builds use short path (C:\\h) to avoid Windows 260-character path limit" >> artifacts-repo/builds/windows/README.md
        echo "- Long path support is enabled via Git configuration" >> artifacts-repo/builds/windows/README.md
        echo "" >> artifacts-repo/builds/windows/README.md
        echo "## Latest Builds" >> artifacts-repo/builds/windows/README.md
        echo "" >> artifacts-repo/builds/windows/README.md
        
        # List all build directories
        for dir in artifacts-repo/builds/windows/hadoop-*; do
          if [ -d "$dir" ]; then
            basename_dir=$(basename "$dir")
            if [ -f "$dir/build-info.json" ]; then
              version=$(grep '"hadoop_version"' "$dir/build-info.json" | cut -d'"' -f4)
              timestamp=$(grep '"build_timestamp"' "$dir/build-info.json" | cut -d'"' -f4)
              commit=$(grep '"hadoop_commit"' "$dir/build-info.json" | cut -d'"' -f4)
              echo "- **$basename_dir**" >> artifacts-repo/builds/windows/README.md
              echo "  - Version: $version" >> artifacts-repo/builds/windows/README.md
              echo "  - Built: $timestamp" >> artifacts-repo/builds/windows/README.md
              echo "  - Commit: $commit" >> artifacts-repo/builds/windows/README.md
              echo "" >> artifacts-repo/builds/windows/README.md
            fi
          fi
        done
        
        echo "BUILD_DIR_NAME=$(basename $BUILD_DIR)" >> $GITHUB_ENV

    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: hadoop-windows-build-${{ env.HADOOP_VERSION }}-${{ env.HADOOP_COMMIT }}
        path: |
          C:\h\hadoop-dist\target\*.tar.gz
          C:\h\hadoop-dist\target\*.zip
        retention-days: 90

    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always() && env.SKIP_TESTS == 'false'
      with:
        name: test-results-${{ env.HADOOP_VERSION }}-${{ env.HADOOP_COMMIT }}
        path: |
          C:\h\**\target\surefire-reports\*.xml
          C:\h\**\target\failsafe-reports\*.xml
        retention-days: 30

    - name: Commit Artifacts to Repository
      if: github.event_name != 'pull_request'
      run: |
        cd artifacts-repo
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add builds/
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Add Hadoop ${{ env.HADOOP_VERSION }} Windows build - ${{ env.BUILD_DIR_NAME }}"
          git push
        fi

    - name: Build Summary
      shell: bash
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "### Source Information" >> $GITHUB_STEP_SUMMARY
        echo "- Repository: ${{ env.HADOOP_REPO }}" >> $GITHUB_STEP_SUMMARY
        echo "- Branch/Tag: ${{ env.HADOOP_BRANCH }}" >> $GITHUB_STEP_SUMMARY
        echo "- Commit: ${{ env.HADOOP_COMMIT }}" >> $GITHUB_STEP_SUMMARY
        echo "- Version: ${{ env.HADOOP_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment" >> $GITHUB_STEP_SUMMARY
        echo "- OS: Windows Server 2022 (windows-latest)" >> $GITHUB_STEP_SUMMARY
        echo "- Java: $(java -version 2>&1 | head -n1)" >> $GITHUB_STEP_SUMMARY
        echo "- Maven: $(mvn --version | head -n1)" >> $GITHUB_STEP_SUMMARY
        echo "- CMake: $(cmake --version | head -n1)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Configuration" >> $GITHUB_STEP_SUMMARY
        echo "- Build Type: ${{ env.BUILD_TYPE }}" >> $GITHUB_STEP_SUMMARY
        echo "- Tests Skipped: ${{ env.SKIP_TESTS }}" >> $GITHUB_STEP_SUMMARY
        echo "- Native Windows build enabled" >> $GITHUB_STEP_SUMMARY
        echo "- OpenSSL support: Yes" >> $GITHUB_STEP_SUMMARY
        echo "- YARN UI v2: Yes" >> $GITHUB_STEP_SUMMARY
        echo "- Documentation: Skipped" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if ls /c/h/hadoop-dist/target/*.tar.gz 1> /dev/null 2>&1; then
          echo "### Artifacts Created" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Distribution tarball created successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ Available in: ${{ env.BUILD_DIR_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ—‚ï¸ Committed to artifacts repository" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ› ï¸ Built using short path workaround (C:\\h)" >> $GITHUB_STEP_SUMMARY
        else
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "âŒ Distribution tarball creation failed" >> $GITHUB_STEP_SUMMARY
        fi

  # Alternative job for Windows Server 2025 (if needed for latest features)
  build-hadoop-windows-2025:
    runs-on: windows-2025
    if: false  # Set to true to enable Windows Server 2025 build
    
    steps:
    # Same steps as above job, but with potential VS 2022 toolset adjustments
    - name: Checkout Hadoop Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup MSVC Dev Environment (VS 2022)
      uses: ilammy/msvc-dev-cmd@v1.3
      with:
        arch: x64
        # Windows Server 2025 may require VS 2022 toolset v143
        toolset: 14.3

    # Note: This job would need all the same steps as the main job
    # but with potential toolset version adjustments
    - name: Build Info
      run: |
        echo "Building on Windows Server 2025 with VS 2022 toolset"
        echo "May require -Duse.platformToolsetVersion=v143 instead of v142"
  compatibility-check:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up JDK 8
      uses: actions/setup-java@v4
      with:
        java-version: '8'
        distribution: 'temurin'

    - name: Setup Python for compatibility check
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Run Compatibility Check
      run: |
        # Install Java API Compliance Checker if needed
        # This step would need the appropriate base branch reference
        echo "Compatibility check would run here"
        # ./dev-support/bin/checkcompatibility.py --annotation org.apache.hadoop.classification.InterfaceAudience.Public --annotation org.apache.hadoop.classification.InterfaceAudience.LimitedPrivate --include "hadoop.*" ${{ github.base_ref }} ${{ github.head_ref }}
