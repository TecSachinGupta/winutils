name: Build Hadoop Native Binaries for Windows

on:
  workflow_dispatch:
    inputs:
      hadoop_version:
        description: 'Comma-separated list of Hadoop versions (e.g., 3.3.6,3.4.1)'
        required: true
        default: '3.4.1'

env:
  # Default Hadoop versions for push/PR events
  DEFAULT_HADOOP_VERSIONS: '3.3.6,3.4.1'

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set matrix from input or default
        id: set-matrix
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.hadoop_version }}" ]; then
            versions="${{ github.event.inputs.hadoop_version }}"
          else
            versions="${{ env.DEFAULT_HADOOP_VERSIONS }}"
          fi
          
          clean_versions=$(echo "$versions" | jq -c -R 'split(",") | map(gsub("^\\s+|\\s+$"; ""))')
          echo "Parsed versions: $clean_versions"
          echo "matrix={\"version\":$clean_versions}" >> $GITHUB_OUTPUT
        shell: bash

  build:
    needs: prepare
    runs-on: windows-latest
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
      fail-fast: false

    steps:
      - name: Echo Hadoop version
        run: echo "Building For Hadoop ${{ matrix.version }}"

      - name: Set variables
        run: |
          echo "RELEASE_TAG=rel/release-${{ matrix.version }}" >> $env:GITHUB_ENV
          echo "DIST_VERSION=hadoop-${{ matrix.version }}" >> $env:GITHUB_ENV

      - name: Set up Java 11 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 11

      - name: Install Python 3
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v2

      - name: Install Native Build Dependencies
        shell: powershell
        run: |
          choco install -y maven git winflexbison3 cmake protoc ninja nasm
          git config --system core.longpaths true

      - name: Checkout Hadoop Source Code
        uses: actions/checkout@v4
        with:
          repository: apache/hadoop
          ref: ${{ env.RELEASE_TAG }}
          path: hadoop

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-hadoop-${{ matrix.version }}-${{ hashFiles('hadoop/**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-hadoop-${{ matrix.version }}-
            ${{ runner.os }}-maven-

      - name: Build Hadoop Native Binaries
        shell: powershell
        run: |
          # Locate Visual Studio vcvars64.bat using vswhere
          $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vsWhere) {
            $vsPath = & $vsWhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
            $vcVarsPath = Join-Path $vsPath 'VC\Auxiliary\Build\vcvars64.bat'
          } else {
            # Fallback paths
            $vcVarsPath = "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
            if (-not (Test-Path $vcVarsPath)) {
              $vcVarsPath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvars64.bat"
            }
          }
          
          Write-Host "Using Visual Studio vcvars64.bat at: $vcVarsPath"
          
          # Try the build with different strategies
          $buildSuccess = $false
          
          # Strategy 1: Build only native components first
          Write-Host "=== Attempting Strategy 1: Native-only build ==="
          try {
            cmd /c "`"$vcVarsPath`" && cd hadoop && mvn clean compile -Pnative -DskipTests -q"
            if ($LASTEXITCODE -eq 0) {
              Write-Host "Native compilation successful, proceeding with full build..."
              cmd /c "`"$vcVarsPath`" && cd hadoop && mvn package -Pdist,native -DskipTests -Dtar -Dmaven.javadoc.skip=true -Ddrfa.src.skip=true"
              if ($LASTEXITCODE -eq 0) {
                $buildSuccess = $true
                Write-Host "=== Strategy 1 successful ==="
              }
            }
          } catch {
            Write-Host "Strategy 1 failed: $($_.Exception.Message)"
          }
          
          # Strategy 2: Skip problematic pre-dist phase
          if (-not $buildSuccess) {
            Write-Host "=== Attempting Strategy 2: Skip pre-dist phase ==="
            try {
              cmd /c "`"$vcVarsPath`" && cd hadoop && mvn clean install -Pdist,native -DskipTests -Dmaven.javadoc.skip=true -Ddrfa.src.skip=true -Dpre-dist.skip=true"
              if ($LASTEXITCODE -eq 0) {
                $buildSuccess = $true
                Write-Host "=== Strategy 2 successful ==="
              }
            } catch {
              Write-Host "Strategy 2 failed: $($_.Exception.Message)"
            }
          }
          
          # Strategy 3: Build individual modules
          if (-not $buildSuccess) {
            Write-Host "=== Attempting Strategy 3: Individual module build ==="
            try {
              # First build hadoop-common with native
              cmd /c "`"$vcVarsPath`" && cd hadoop && mvn clean install -pl hadoop-common-project/hadoop-common -Pnative -DskipTests -q"
              
              # Then build hadoop-hdfs with native  
              cmd /c "`"$vcVarsPath`" && cd hadoop && mvn clean install -pl hadoop-hdfs-project/hadoop-hdfs -Pnative -DskipTests -q"
              
              # Finally build the distribution
              cmd /c "`"$vcVarsPath`" && cd hadoop && mvn clean package -pl hadoop-dist -Pdist -DskipTests -Dtar -Dmaven.javadoc.skip=true"
              
              if ($LASTEXITCODE -eq 0) {
                $buildSuccess = $true
                Write-Host "=== Strategy 3 successful ==="
              }
            } catch {
              Write-Host "Strategy 3 failed: $($_.Exception.Message)"
            }
          }
          
          if (-not $buildSuccess) {
            Write-Host "=== All build strategies failed ==="
            Write-Host "Attempting to extract any built native libraries..."
            
            # Try to find any native libraries that may have been built
            $possiblePaths = @(
              "hadoop\hadoop-common-project\hadoop-common\target\native\target\usr\local\lib",
              "hadoop\hadoop-hdfs-project\hadoop-hdfs\target\native\target\usr\local\lib", 
              "hadoop\hadoop-common-project\hadoop-common\src\main\native\target\usr\local\lib"
            )
            
            foreach ($path in $possiblePaths) {
              if (Test-Path $path) {
                Write-Host "Found native libraries at: $path"
                Get-ChildItem -Path $path -Recurse -File | ForEach-Object {
                  Write-Host "  $($_.Name)"
                }
              }
            }
            
            Write-Host "Build failed but continuing to check for partial artifacts..."
          }

      - name: Verify native libraries
        shell: powershell
        run: |
          Write-Host "=== Searching for native libraries ==="
          
          # Primary locations to check
          $searchPaths = @(
            "hadoop\hadoop-dist\target\${{ env.DIST_VERSION }}\lib\native",
            "hadoop\hadoop-dist\target\hadoop-${{ matrix.version }}\lib\native", 
            "hadoop\hadoop-common-project\hadoop-common\target\native\target\usr\local\lib",
            "hadoop\hadoop-hdfs-project\hadoop-hdfs\target\native\target\usr\local\lib",
            "hadoop\hadoop-common-project\hadoop-common\src\main\native\target\usr\local\lib"
          )
          
          $foundLibraries = @()
          
          foreach ($path in $searchPaths) {
            if (Test-Path $path) {
              Write-Host "Found native directory: $path"
              $files = Get-ChildItem -Path $path -Recurse -File -ErrorAction SilentlyContinue
              foreach ($file in $files) {
                Write-Host "  $($file.Name) - $($file.Length) bytes"
                $foundLibraries += $file.FullName
              }
            }
          }
          
          if ($foundLibraries.Count -eq 0) {
            Write-Host "No native libraries found. Searching entire hadoop directory for .dll and .exe files..."
            $allNativeFiles = Get-ChildItem -Path "hadoop" -Recurse -Include "*.dll", "*.exe", "*.so" -ErrorAction SilentlyContinue
            foreach ($file in $allNativeFiles) {
              Write-Host "Found: $($file.FullName)"
              $foundLibraries += $file.FullName
            }
          }
          
          # Check for winutils specifically
          $winutilsFiles = Get-ChildItem -Path "hadoop" -Recurse -Name "winutils.exe" -ErrorAction SilentlyContinue
          if ($winutilsFiles) {
            Write-Host "=== Found winutils.exe ==="
            foreach ($winutil in $winutilsFiles) {
              Write-Host "  $winutil"
            }
          }
          
          # Set environment variable for packaging step
          $env:NATIVE_LIBS_FOUND = $foundLibraries.Count.ToString()
          echo "NATIVE_LIBS_FOUND=$($foundLibraries.Count)" >> $env:GITHUB_ENV

      - name: Package native libraries and winutils
        shell: powershell
        run: |
          $version = "${{ matrix.version }}"
          $outputDir = "hadoop-$version-native-windows"
          
          # Create output directory
          New-Item -ItemType Directory -Path $outputDir -Force
          
          $artifactsFound = $false
          
          # Search for and copy native libraries from various possible locations
          $searchPaths = @(
            "hadoop\hadoop-dist\target\${{ env.DIST_VERSION }}\lib\native",
            "hadoop\hadoop-dist\target\hadoop-$version\lib\native",
            "hadoop\hadoop-common-project\hadoop-common\target\native\target\usr\local\lib",
            "hadoop\hadoop-hdfs-project\hadoop-hdfs\target\native\target\usr\local\lib"
          )
          
          foreach ($searchPath in $searchPaths) {
            if (Test-Path $searchPath) {
              Write-Host "Copying native libraries from: $searchPath"
              $libOutputDir = "$outputDir\lib\native"
              New-Item -ItemType Directory -Path $libOutputDir -Force
              Copy-Item -Path "$searchPath\*" -Destination $libOutputDir -Recurse -Force -ErrorAction SilentlyContinue
              $artifactsFound = $true
              break
            }
          }
          
          # Search for and copy bin directory (including winutils.exe)
          $binSearchPaths = @(
            "hadoop\hadoop-dist\target\${{ env.DIST_VERSION }}\bin",
            "hadoop\hadoop-dist\target\hadoop-$version\bin"
          )
          
          foreach ($binPath in $binSearchPaths) {
            if (Test-Path $binPath) {
              Write-Host "Copying bin directory from: $binPath"
              $binOutputDir = "$outputDir\bin"
              New-Item -ItemType Directory -Path $binOutputDir -Force
              Copy-Item -Path "$binPath\*" -Destination $binOutputDir -Recurse -Force -ErrorAction SilentlyContinue
              $artifactsFound = $true
              break
            }
          }
          
          # If primary locations failed, search for individual files
          if (-not $artifactsFound) {
            Write-Host "Primary locations not found, searching for individual native files..."
            
            # Search for any .dll, .exe files in the entire hadoop directory
            $nativeFiles = Get-ChildItem -Path "hadoop" -Recurse -Include "*.dll", "winutils.exe", "hadoop.exe" -ErrorAction SilentlyContinue
            
            if ($nativeFiles) {
              Write-Host "Found individual native files:"
              $libOutputDir = "$outputDir\lib\native"
              $binOutputDir = "$outputDir\bin"
              New-Item -ItemType Directory -Path $libOutputDir -Force
              New-Item -ItemType Directory -Path $binOutputDir -Force
              
              foreach ($file in $nativeFiles) {
                Write-Host "  Copying: $($file.Name)"
                if ($file.Extension -eq ".dll") {
                  Copy-Item -Path $file.FullName -Destination $libOutputDir -Force
                } else {
                  Copy-Item -Path $file.FullName -Destination $binOutputDir -Force
                }
                $artifactsFound = $true
              }
            }
          }
          
          # Create README with build info
          $buildStatus = if ($artifactsFound) { "SUCCESS (Partial)" } else { "FAILED" }
          $readme = @"
          Hadoop $version Native Binaries for Windows
          Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
          Build Status: $buildStatus
          Source: Apache Hadoop $version (tag: ${{ env.RELEASE_TAG }})
          
          Contents:
          - lib/native/: Native libraries (.dll files) if available
          - bin/: Windows utilities including winutils.exe if available
          
          Build Notes:
          - Built using multiple fallback strategies due to Hadoop Windows build complexity
          - Some components may be missing if the full build failed
          - Check BUILD_LOG.txt for detailed build information
          
          These binaries were built using:
          - Java 11 (Temurin)
          - Visual Studio 2022
          - Maven with various native profiles
          "@
          
          $readme | Out-File -FilePath "$outputDir\README.txt" -Encoding UTF8
          
          # Create build status file
          $buildLog = @"
          Build attempted with multiple strategies:
          1. Native-only build first, then full build
          2. Skip pre-dist phase build
          3. Individual module builds
          
          Native libraries found: $env:NATIVE_LIBS_FOUND
          Artifacts packaged: $artifactsFound
          
          For detailed build logs, check the GitHub Actions build logs.
          "@
          
          $buildLog | Out-File -FilePath "$outputDir\BUILD_LOG.txt" -Encoding UTF8
          
          if (-not $artifactsFound) {
            Write-Host "Warning: No native artifacts found"
            "Build completed but no native libraries or binaries were found.`nThis may be due to build failures. Check the GitHub Actions logs for details." | Out-File -FilePath "$outputDir\BUILD_ERROR.txt"
          }
          
          # Create archive regardless of success/failure for debugging
          Compress-Archive -Path $outputDir -DestinationPath "hadoop-$version-native-windows.zip" -Force
          Write-Host "Package created: hadoop-$version-native-windows.zip"
          
          # List final package contents
          Write-Host "=== Final package contents ==="
          Get-ChildItem -Path $outputDir -Recurse | ForEach-Object {
            Write-Host "  $($_.FullName.Replace($outputDir, ''))"
          }

      - name: Upload native libraries artifact
        uses: actions/upload-artifact@v4
        with:
          name: hadoop-${{ matrix.version }}-native-windows
          path: hadoop-${{ matrix.version }}-native-windows.zip
          retention-days: 30

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-hadoop-${{ matrix.version }}
          path: |
            hadoop/**/*.log
            hadoop/**/target/surefire-reports/
          retention-days: 7
